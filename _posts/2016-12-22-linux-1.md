---
layout: post
title: "Linux 공부 1"
description: 
headline: 
modified: 2016-12-22
category: Linux
tags: [Linux, Study]
imagefeature: 
mathjax: 
chart: 
comments: true
featured: true
---

Unix 파워툴 책을 기반으로 유닉스와 리눅스에 대해 학습하고 기록해본다.

# 기본 개념

### 작동방식
* 사용자는 **쉘**이라는 프로그램과 대화 (키보드 입력이 바로 Unix와 대화를 의미하는 것이 아님)  
* 쉘은 사용자로부터 Unix를 보호하며, 또한 Unix로부터 사용자를 보호  
* 유닉스의 모든 일은 소위 **커널**이 처리  
* 프로그램들 만이 **시스템 콜**을 통해 커널과 대화  
* 쉘은 사용자가 입력한 명령어를 해석해서 실행시키거나 또는 다른 프로그램에게 넘겨주는 역할  

#### Example
m으로 시작하는 4자로 된 파일들의 이름을 출력하기 위한 명령은 아래와 같다.  
{% highlight bash %}
  $ cat m???    
{% endhighlight %}
- Shell이 이름 조건에 맞는 파일들을 찾아서 목록을 작성 -> cat명령어를 호출하여 목록에 있는 파일들을 출력  
- 명령어 cat은 각각의 파일을 디스크에서 찾기 위해 커널을 호출 -> 파일의 내용을 화면에 출력  
  
일반적으로 Shell은 공백문자(스페이스나 탭)을 기준으로 명령행의 각 인자를 분리하지만 가끔 **인용부호**로 인자들을 묶어서 쉘에게 알려주어야 할 때가 있다.
{% highlight bash %}
  $ grep "UNIX Power Tools" articles/
{% endhighlight %}
  
명령어 중에는 쉘이 중재하지 않고 사용자로부터 **직접 입력**을 받는 것들이 있다.(대화식 명령어). 그러나 대화식 명령어도 쉘이 실행시킨다.

### 서로 협력하는 프로그램들
 프로그램은 도구이며, 이런저런 용도로 이용될 수 있어야 한다. 프로그램이 범용적으로 이용될 수 있으려면 반드시 데이터에 독립적이야 한다. 이런 방식으로 이용될 수 있는 프로그램들을 흔히 **필터**라고 부른다  
  - 한 프로그램의 출력은 다른 프로그램의 입력으로 이용될 수 있어야 한다.  
  - 프로그램이 필요로 하는 모든 정보는 데이터 스트림의 형태로 프로그램에 공급이 되거나 명령행에 지정이 되어야 한다.
  - 주어진 인자가 없의면 프로그램은 표준 입력(터미널 키보드)에서 읽고 표준 출력(터미널 화면)으로 출력한다.  
  
Unix에서는 한 프로그램의 출력을 다른 프로그램의 입력으로 이용하도록 **파이프라인**을 이용해서 함께 엮는 것이 가능하다. 파이프를 나타내는 문자는 수직바(\|)로서 '왼쪽 프로그램의 실행 결과를 오른쪽 프로그램의 입력으로 공급하라' 라는 뜻을 갖는다.

#### Example
 Unix에 담겨있는 툴들은 범용적인 것으로서 파이프 등으로 쉽게 엮을 수 있다.  
만일 어떤 문서 내에서 'which'라는 단어를 잘못 사용하지 않았나 찾고싶다면 아래와 같이 명령행에 입력하면 된다.
{% highlight bash %}
  $ grep '[Ww]ich' chapter1 | more
{% endhighlight %}
more 명령어는 출력을 한 화면 단위로 끊어서 보여준다.  
인덱스 항목들의 일관성을 검사하려면 아래와 같이 명령행에 입력을 하면 된다.  
{% highlight bash %}
  $ cat files | grep .XX | sort -u | more
{% endhighlight %}
 - files: 검사할 파일들  
 - grep: 지정한 문자열이나 패턴이 있는지 검색  
 - sort -u: grep이 찾아낸 라인들을 알파벳 순서로 정렬하면서 중복된 라인을 제거  
 - more: 출력을 한 화면 단위로 끊어서 보여줌  

### 쉘 프로그래밍
쉘은 그 자체로도 **완벽한** 프로그래밍 언어이다. 파일 내의 특정 문자를 모두 다른 문자로 치환하려면 아래와 같이 명령행에 입력해주면 된다.
{% highlight bash %}
  $ tr '\015' '\012' < filename > file.UNIX
{% endhighlight %}
하지만 이 명령을 모두 외우기 힘들기 때문에 mac2unix라는 파일로 지정해줄 수 있다.
{% highlight bash %}
  #mac2unix

  for x
  do
    echo "converting $x"
    tr '\015' '\012' < "$x" > "tmp.$x"
    mv "tmp.$x" "$x"
  done
{% endhighlight %}
위 파일을 사용하려면 아래와 같이 명령행을 입력하면 된다.
{% highlight bash %}
  $ mac2unix file1, file2, file3
{% endhighlight %}
위와 같이 입력해주면 모든 파일의 특정 문자를 다른 문자로 치환해줄 수 있다.

### 여러가지 쉘들
쉘은 여러 종류가 있으며, 자신에게 적합한 것을 자유롭게 선택해서 이용할 수 있다.
 - sh: Broune Shell  
 - csh: 버클리 대학에서 개발  
 - ksh: Korn쉘  
 - bash: Bourne-again Shell, 자유소프트웨어 재단에서 개발
 - tcsh: C shell의 확장판  

### 내가 이용하고 있는 쉘
내가 이용하고 있는 쉘을 확인하는 방법은 아래와 같다.
{% highlight bash %}
  $ grep username /etc/passwd
  $ ypcat passwd | grep username
  /bin/csh or /usr/bin/csh => csh
  /bin/sh = Broune shell or Korn shell
{% endhighlight %}

### 내부 명령어와 외부 명령어
 - 내부 명령어: 쉘에 포함된 명령어  
 - 외부 명령어: 환경변수 PATH에 설정된 디렉토리 목록이 존재  

### 쉘이 다른 명령어를 실행시키는 방법
Unix프로그램은 **fork**와 **exec**이라고 하는 2개의 시스템콜을 통해 실행된다.
 - exec: 커널에게 프로그램을 실행하도록 지시함, 호출되는 프로그램은 실행 후 원래의 프로그램으로 되돌아갈 수 가 없다.  
 - fork: 시스템 콜을 통해 자기 복제를 한 후 복제된 프로그램이 새 프로그램을 exec한다. 복제된 프로그램은 호출되는 프로그램으로 변신하여 역할을 수행한 후 종료된다.
  
### 쉘스크립트의 정체
쉘 스크립트는 단순한 **ASCII**파일이다. 일련의 순차적 명령어로 구성된 텍스트파일일 뿐이다. 한번의 사용을 위해 다수의 명령어들을 하나의 파일에 담아 놓았다면 다음과 같이 실행시킬 수 있다.
{% highlight bash %}
  $ sh mycommands
{% endhighlight %}
chmod명령어를 이용하여 파일을 실행가능하도록 만들 수 있다.  
{% highlight bash %}
  $ chmod +x mycommands  
{% endhighlight %}

### 커널과 데몬
 - UNIX: 다중 사용자 운영체제  
 - 커널: Unix 운영체제의 핵심, 실행중인 각 프로그램에 메모리를 할당하고 각 프로그램을 공정한 시간씩 돌아가며 실행시켜주며, 모든 입출력 작업을 처리한다. 서로 상이한 여러 작업을 스케쥴하는 관리자  
 - 데몬: 필요에 따라 실행, 메일 처리, 네트워크 통신, 데이터를 프린터로 전송, 현재시간 조절등의 일을 수행  
 - ps -el 을 입력해보면 실행중인 서비스들을 확인할 수 있다.  

### 파일명
파일명은 /를 제외한 거의 모든 문자를 사용할 수 있다. 
 - 파일명은 대소문자를 구분한다.  
 - 밑줄 문자를 사용하는 것이 좋다.  
 - 점(.)문자로 시작하는 파일을 설정파일이며 감춰진 파일이다.  

### 와일드카드
와일드카드는 파일명을 줄여서 이용하거나 파일을 그룹단위로 참조할 떄 이용된다.  
와일드카드는 Unix 파일시스템이 아닌 쉘에 정의된 것  
 - ?: 임의의 문자 하나  
 - \*: 0개 이상의 임의의 문자들  
 - \[ab\]: a또는 b  
 - \[a-z\]: a에서 z사이의 문자 하나  

### 파일명 확장자
 - Unix에는 파일확장자라는 개념이 없다.
 - .은 특별한 의미가 없으며, 확장자의 길이도 제약이 없다.
 - 일부 프로그램은 한 글자짜리 확장자를 이용해 파일의 종류를 인식하기도 한다.
 - 파일의 내용이 무엇인지 쉽게 알아볼 수 있도록 임의의 확장자를 붙이기도 한다.

### Unix 파일 시스템의 주요 디렉토리

<div class="row">
    <div class="large-12 columns">
        <table>
          <thead>
            <tr>
              <th width="150">디렉토리</th>
              <th>목적</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>/</td>
              <td>루트 디렉토리</td>
            </tr>
            <tr>
              <td>/bin(or /sbin)</td>
              <td>시스템을 부팅하는 데 필요한 핵심 실행 파일이 저장된 디렉토리</td>
            </tr>
            <tr>
              <td>/dev</td>
              <td>시스템에 연결된 장치들, 예를들어 터미널, 디스크, 테이프, 모뎀</td>
            </tr>
            <tr>
              <td>/etc</td>
              <td>패스워드, 네트워크 주소와 이름, 시스템 시작 설정 등을 포함하는 시스템</td>
            </tr>
            <tr>
              <td>/home</td>
              <td>사용자 디렉토리</td>
            </tr>
            <tr>
              <td>/lib</td>
              <td>프로그램을 위한 다양한 공용 라이브러리들의 홈</td>
            </tr>
            <tr>
              <td>/mnt</td>
              <td>다른 시스템으로부터 익스포트 된 파일 시스템들을 임시로 마운트하고 있는 위치</td>
            </tr>
            <tr>
              <td>/proc</td>
              <td>시스템에서 현재 실행되고 있는 프로세스들의 이미지</td>
            </tr>
            <tr>
              <td>/tmp</td>
              <td>부팅 중 없어질 임시 파일들, 재부팅되면 여기 있는 모든 파일들은 지워진다.</td>
            </tr>
            <tr>
              <td>/usr</td>
              <td>/usr/bin은 일부 표준 시스템 유틸리티, /usr/man은 맨페이지, /usr/include는 C프로그램 헤더, /usr/sbin은 관리자 실행 프로그램</td>
            </tr>
            <tr>
              <td>/var</td>
              <td>주로 관리자 용인 다양한 파일들을 저장하는 디렉토리. 특히 log파일은 /var/log에 기록</td>
            </tr>
          </tbody>
        </table>
    </div>
</div>
 - Unix는 부팅시 /etc파일의 설정을 이용해 초기에 필요한 리소스와 데몬 등을 로딩한다.  
 - 부팅시 시스템의 설정을 하기 위한 스크립트는 /etc/init.d와 /etc/rc.d이다.
 - 이 설정 파일들을 이용해 시스템 로딩을 하는 프로세스가 init이다.
 - init은 System Logging을 위한 작업, 시스템을 위한 작업 스케쥴링, 네트워크 설정 등을 포함하는 스크립트를 보고 필요한 작업을 진행한다.  

### 파일 액세스 퍼미션
Unix파일은 사용자 및 그룹에 기반하여 액세스를 허가하거나 금지한다.  
만일 data라는 파일을 through라는 사용자와 others라는 그룹으로 소유권을 변경하려면 아래와 같이 명령행에 입력한다.
{% highlight bash %}
  $ chgrp others data
  $ chown through data
{% endhighlight %}
소유주와 그룹을 동시에 변경하고 싶다면 그룹을 먼저 변경해주어야 한다. 일부 버전의 chown은 동시에 변경하는 기능을 제공하기도 한다.  

파일을 액세스 할 수 있는지 없는지에 대한 권한은 파일의 소유자 및 파일이 속한 그룹뿐만이 아니라 모드비트라고 하는 **액세스 비트**의 값과도 관련이 있다. 파일의 소유자 / 파일이 속한 그룹의 멤버 / 기타 라는 세 클래스가 있고, 각 클래스에 대한 읽기, 쓰기, 실행을 의미하는 비트가 정의되어 있다.
<div class="row">
    <div class="large-12 columns">
        <table>
            <tr>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td bgcolor="lightgrey">0</td>
                <td bgcolor="lightgrey">0</td>
                <td bgcolor="lightgrey">0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
            </tr>
        </table>
    </div>
</div>
모드비트는 ls -l 의 출력을 통해 확인할 수 있다.
{% highlight bash %}
  -rw-------       #모드 600
  -rwxrwxrwx       #모드 777
  -rw-rw-rw-       #모드 666
{% endhighlight %}

### 디렉토리 액세스
디렉토리에도 파일과 똑같은 모드비트가 이용되지만 의미는 사뭇 다르다. 디렉토리는 파일들의 목록일 뿐이기 때문  
 - 파일 생성, 파일이름 변경, 삭제등의 작업은 목록에 변경을 가함 -> 디렉토리 쓰기 권한이 필요  
 - 파일 내용수정은 디렉토리에 변경을 가하지 않음 -> 디렉토리 쓰기 권한 없이도 가능  
 - 디렉토리 읽기 권한이 없으면 파일목록을 알 수 없다. 그러나 파일 경로를 정확히 알면 파일에 액세스 할 수 있다.
 - 디렉토리 실행권한은 검색비트 용도. 실행권한이 없다면 그 디렉토리와 하부 디렉토리를 액세스 할 수 없다.

### 다중사용자 시스템

